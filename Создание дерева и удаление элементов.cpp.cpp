#include <iostream>
#include <iomanip>
#include <fstream>

using namespace std;

const int n = 2;
const int nn = 4; // Кол-во эл-ов на странице
struct item; // Прототип структуры

struct page
{
	short m;	// Число элементов на странице
	page* p0;	// Указатель на левую страницу-потомка
	item* e[nn];// Массив указателей на элементы
};

struct item
{
	long key;   // Ключ
	page* p;	// Указатель на правую страницу-потомка
	long count; // Число элементов с данным ключом
};

void search(long int x, page* a, bool& h, item*& v)
{
	long int i, k, L, r;
	page* b;
	page* q = NULL;
	item* u = NULL;

	if (a == NULL) // 1-ая запись
	{
		v = new(item);
		h = true;
		(*v).key = x;
		(*v).count = 1;
		(*v).p = NULL;
	}
	else // Последующие записи
	{

		L = 1;
		r = (*a).m;
		do // Двоичный поиск в массиве
		{
			k = (L + r) / 2;

			if (x <= (*(*a).e[k]).key)
			{
				r = k - 1;
			}
			if (x >= (*(*a).e[k]).key)
			{
				L = k + 1;
			}

		} while (r > L);

		if ((L - r) > 1) // вхождение элемента найдено 
		{
			(*(*a).e[k]).count += 1;
			h = false;
		}
		else //элемента нет на этой странице q 
		{
			if (r == 0)
			{
				q = (*a).p0;
			}
			else
			{
				q = (*(*a).e[r]).p;
			}
			search(x, q, h, u);

			if (h)
			{
				if ((*a).m < nn) // Если количество эл-ов на странице больше заданного
				{
					(*a).m++; // Увеличение кол-ва эл-ов
					h = false;
					for (i = (*a).m; i >= r + 2; i--) // Сдвиг ячеек массива е для осовбождения места под новую ячейку, содержащей ключ и ссылку на вершину-сына
					{
						(*a).e[i] = (*a).e[i - 1];
					}
					(*a).e[r + 1] = u; // Присваивание значения ключа и указателя на вершину следующего уровня
				}
				else // Если количество эл - ов на странице больше заданного с учётом нового
				{
					b = new(page); // Создание новой вершины
					if (r <= n) 
					{ //Место (r), на этом уровне <= половине макс-го кол-ва эл-ов массива «е»
						if (r == n)
						{
							v = u;
						}
						else
						{
							v = (*a).e[n];
							for (i = n; i >= r + 2; i--)
							{
								(*a).e[i] = (*a).e[i - 1];
							}
							(*a).e[r + 1] = u;
						}
						for (i = 1; i <= n; i++)
						{
							(*b).e[i] = (*a).e[i + n];
						}
					}
					else // включение u в первую страницу
					{
						r = r - n;
						v = (*a).e[n + 1];
						for (i = 1; i <= r - 1; i++)
						{
							(*b).e[i] = (*a).e[i + n + 1];
						}

						(*b).e[r] = u;
						for (i = r + 1; i <= n; i++)
						{
							(*b).e[i] = (*a).e[i + n];
						}
					}
					(*a).m = n;
					(*b).m = n;
					(*b).p0 = (*v).p;
					(*v).p = b;
				}
			}
		}
	}
}

void printtree(page* pr, long int L)
{
	long int i; item* u;
	if (pr != NULL)
	{
		cout << "m = " << (*pr).m;
		for (i = 1; i <= L; i++)
		{
			cout << " ";
		}

		for (i = 1; i <= (*pr).m; i++)
		{
			cout << setw(4) << (*(*pr).e[i]).key;
		}
		cout << endl;

		printtree((*pr).p0, L + 1); // Вывод "правой страницы"
		for (i = 1; i <= (*pr).m; i++)
		{
			printtree((*(*pr).e[i]).p, L + 1); // Вывод "левой страницы"
		}

	}
}

void underflow(page* c, page* a, int s, bool& h) // с - предок, а - с нехваткой
{
	page* b;
	int k, mb, mc;
	mc = (*c).m;
	h = true;
	(*a).m = n - 1;
	if (s < mc) // б страница справа от а
	{ 
		s++;
		b = (*c).e[s]->p;
		mb = (*b).m;
		k = (mb - n + 1) / 2;
		(*a).e[n] = (*c).e[s];
		(*a).e[n]->p = (*b).p0;
		if (k > 0) // Если элементов на соседней странице б больше 0 то пересылка к элементов с б на а
		{ 
			for (int i = 1; i <= k - 1; i++)
			{
				(*a).e[i + n] = (*b).e[i];
			}
			(*c).e[s] = (*b).e[k];
			(*c).e[s]->p = b;
			(*b).p0 = (*b).e[k]->p;
			mb = mb - k;
			for (int i = 1; i <= mb; i++)
			{
				(*b).e[i] = (*b).e[i + k];
			}
			(*b).m = mb; (*a).m = n - 1 + k;
			h = false;
		}
		else// Слияние страниц а и б
		{ 
			for (int i = 1; i <= n; i++)
			{
				(*a).e[i + n] = (*b).e[i];
			}
			for (int i = s; i <= mc - 1; i++)
			{
				(*c).e[i] = (*c).e[i + 1];
			}
			(*a).m = nn;
			(*c).m = mc - 1;
			delete(b);
			h = (*c).m < n;
		}
	}
	else // б страница слева от а
	{
		if (s == 1)
		{
			b = (*c).p0;
		}
		else
		{
			b = (*c).e[s - 1]->p;
		}
		mb = (*b).m + 1;
		k = (mb - n) / 2;
		if (k > 0)// Пересылка к элементов с б на а
		{ 
			for (int i = n - 1; i >= 1; i--)
			{
				(*a).e[i + k] = (*a).e[i];
			}
			(*a).e[k] = (*c).e[s];
			(*a).e[k]->p = (*a).p0;
			mb = mb - k;
			for (int i = k - 1; i >= 1; i--)
			{
				(*a).e[i] = (*b).e[i + mb];
			}
			(*a).p0 = (*b).e[mb]->p;
			(*c).e[s] = (*b).e[mb];
			(*c).e[s]->p = a;
			(*b).m = mb - 1;
			(*a).m = n - 1 + k;
			h = false;
		}
		else// Слияние страниц а и б
		{ 
			(*b).e[mb] = (*c).e[s];
			(*b).e[mb]->p = (*a).p0;
			for (int i = 1; i <= n - 1; i++)
			{
				(*b).e[i + mb] = (*a).e[i];
			}
			(*b).m = nn;
			(*c).m = mc - 1;
			delete(a);
			h = (*c).m < n;
		}
	}
}

void del(page* p, bool& h, page*& a, int& k)
{
	page* q;
	q = (*p).e[(*p).m]->p;
	if (q != NULL)
	{
		del(q, h, a, k);
		if (h)
		{
			underflow(p, q, (*p).m, h);
		}
	}
	else
	{
		(*p).e[(*p).m]->p = (*a).e[k]->p;
		(*a).e[k] = (*p).e[(*p).m];
		(*p).m = (*p).m - 1;
		h = (*p).m < n;
	}
}

void delet(int x, page* a, bool& h)
{
	int k, l, r;
	page* q;
	if (a == NULL)
	{
		cout << "Ключа нет в дереве!" << endl;
		h = false;
	}
	else
	{
		l = 1;
		r = (*a).m; // Двоичный поиск в массиве
		do
		{
			k = (l + r) / 2; //if (k == 0) k++;
			if (x <= (*a).e[k]->key)
			{
				r = k - 1;
			}
			if (x >= (*a).e[k]->key)
			{
				l = k + 1;
			}
		} while (l <= r);
		if (r == 0)
		{
			q = (*a).p0;
		}
		else
		{
			q = (*a).e[r]->p;
		}
		if (l - r > 1)// Удаление е[k]
		{ 
			if (q == NULL)
			{
				(*a).m = (*a).m - 1;
				h = (*a).m < n;
				for (int i = k; i <= (*a).m; i++)
				{
					(*a).e[i] = (*a).e[i + 1];
				}
			}
			else
			{
				del(q, h, a, k);
				if (h)
				{
					underflow(a, q, r, h);
				}
			}
		}
		else
		{
			delet(x, q, h);
			if (h)
			{
				underflow(a, q, r, h);
			}
		}
	}
}

void zapolnfile()
{
	srand(time(NULL));

	ofstream ff;
	ff.open("input.txt");

	for (int i = 0; i < 300; i++)
	{
		if (i != 299)
		{
			ff << rand() % 999 << endl;
		}
		else
		{
			ff << rand() % 999;
		}
	}
	ff.close();
}

int main()
{
	
	setlocale(LC_ALL, "RUS");
	//zapolnfile();
	
	page* Root = NULL;
	page* q;
	item* u = NULL;

	long int x;
	bool h = false;

	ifstream f;
	f.open("input.txt");

	int n;
	cout << "Введите кол-во элементов для заполнения дерева: ";
	cin >> n;
	cout << endl;

	u = new(item);
	while(!f.eof() && n != 0)
	{
		n--;
		f >> x;
		cout << "Поступивший ключ: " << x;
		search(x, Root, h, u);
		if (h)
		{
			q = Root;
			Root = new(page);
			{
				(*Root).m = 1;
				(*Root).p0 = q;
				(*Root).e[1] = u;
			}
		}
		cout << endl << "Дерево:" << endl;
		printtree(Root, 1);
		cout << endl;
	}
	f.close();

	cout << endl << "Количество удаляемых элементов: ";
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cout << "Удаляемый элемент: ";
		cin >> x;

		delet(x, Root, h);
		if (h)
		{
			if ((*Root).m == 0)
			{
				q = Root;
				Root = (*q).p0;
				delete(q);
			}
		}

		cout << "Дерево после удаления:" << endl;
		printtree(Root, 1);
	}

}


//Введите кол - во элементов для заполнения дерева : 6
//
//Поступивший ключ : 427
//Дерево :
//	m = 1  427
//
//	Поступивший ключ : 764
//	Дерево :
//	m = 2  427 764
//
//	Поступивший ключ : 615
//	Дерево :
//	m = 3  427 764 615
//
//	Поступивший ключ : 119
//	Дерево :
//	m = 4  427 119 764 615
//
//	Поступивший ключ : 703
//	Дерево :
//	m = 1  703
//	m = 2   427 119
//	m = 2   764 615
//
//	Поступивший ключ : 62
//	Дерево :
//	m = 1  703
//	m = 3    62 427 119
//	m = 2   764 615
//
//
//	Количество удаляемых элементов : 6
//	Удаляемый элемент : 703
//	Дерево после удаления :
//m = 1  119
//m = 2    62 427
//m = 2   764 615
//Удаляемый элемент : 119
//Дерево после удаления :
//m = 4   62 427 764 615
//Удаляемый элемент : 62
//Дерево после удаления :
//m = 3  427 764 615
//Удаляемый элемент : 427
//Дерево после удаления :
//m = 2  764 615
//Удаляемый элемент : 764
//Дерево после удаления :
//m = 1  615
//Удаляемый элемент : 615


//Введите кол - во элементов для заполнения дерева : 7
//
//Поступивший ключ : 427
//Дерево :
//	m = 1  427
//
//	Поступивший ключ : 764
//	Дерево :
//	m = 2  427 764
//
//	Поступивший ключ : 615
//	Дерево :
//	m = 3  427 764 615
//
//	Поступивший ключ : 119
//	Дерево :
//	m = 4  427 119 764 615
//
//	Поступивший ключ : 703
//	Дерево :
//	m = 1  703
//	m = 2   427 119
//	m = 2   764 615
//
//	Поступивший ключ : 62
//	Дерево :
//	m = 1  703
//	m = 3    62 427 119
//	m = 2   764 615
//
//	Поступивший ключ : 478
//	Дерево :
//	m = 1  703
//	m = 4    62 427 119 478
//	m = 2   764 615
//
//
//	Количество удаляемых элементов : 5
//	Удаляемый элемент : 478
//	Дерево после удаления :
//m = 1  703
//m = 3    62 427 119
//m = 2   764 615
//Удаляемый элемент : 119
//Ключа нет в дереве!
//Дерево после удаления :
//m = 1  703
//m = 3    62 427 119
//m = 2   764 615
//Удаляемый элемент : 427
//Дерево после удаления :
//m = 1  703
//m = 2    62 119
//m = 2   764 615
//Удаляемый элемент : 615
//Ключа нет в дереве!
//Дерево после удаления :
//m = 1  703
//m = 2    62 119
//m = 2   764 615
//Удаляемый элемент : 764
//Дерево после удаления :
//m = 4   62 119 703 615

//Введите кол - во элементов для заполнения дерева : 5
//
//Поступивший ключ : 427
//Дерево :
//	m = 1  427
//
//	Поступивший ключ : 764
//	Дерево :
//	m = 2  427 764
//
//	Поступивший ключ : 615
//	Дерево :
//	m = 3  427 764 615
//
//	Поступивший ключ : 119
//	Дерево :
//	m = 4  427 119 764 615
//
//	Поступивший ключ : 703
//	Дерево :
//	m = 1  703
//	m = 2   427 119
//	m = 2   764 615
//
//
//	Количество удаляемых элементов : 2
//	Удаляемый элемент : 764
//	Дерево после удаления :
//m = 4  427 119 703 615
//Удаляемый элемент : 703
//Дерево после удаления :
//m = 3  427 119 615




//////////////////////////////// тесты 8 лабораторной


//Введите ключ : 45
//Дерево :
//	m = 1   45
//
//	Введите ключ : 55
//	Дерево :
//	m = 2   45  55
//
//	Введите ключ : 65
//	Дерево :
//	m = 3   45  55  65
//
//	Введите ключ : 75
//	Дерево :
//	m = 4   45  55  65  75
//
//	Введите ключ : 85
//	Дерево :
//	m = 1   65
//	m = 2    45  55
//	m = 2    75  85
//
//	Введите ключ : 10
//	Дерево :
//	m = 1   65
//	m = 3    10  45  55
//	m = 2    75  85
//
//	Введите ключ : 20
//	Дерево :
//	m = 1   65
//	m = 4    10  20  45  55
//	m = 2    75  85
//
//	Введите ключ : 70
//	Дерево :
//	m = 1   65
//	m = 4    10  20  45  55
//	m = 3    70  75  85
//
//	Введите ключ : 90
//	Дерево :
//	m = 1   65
//	m = 4    10  20  45  55
//	m = 4    70  75  85  90
//
//	Введите ключ : 100
//	Дерево :
//	m = 2   65  85
//	m = 4    10  20  45  55
//	m = 2    70  75
//	m = 2    90 100
//
//	Введите ключ : 0
//
//	Дерево заполнено

//Введите ключ : 5
//Дерево :
//	m = 1    5
//
//	Введите ключ : 2
//	Дерево :
//	m = 2    2   5
//
//	Введите ключ : 4
//	Дерево :
//	m = 3    2   5   4
//
//	Введите ключ : 7
//	Дерево :
//	m = 4    2   5   4   7
//
//	Введите ключ : 8
//	Дерево :
//	m = 1    4
//	m = 2     2   5
//	m = 2     7   8
//
//	Введите ключ : 9
//	Дерево :
//	m = 1    4
//	m = 2     2   5
//	m = 3     7   8   9
//
//	Введите ключ : 0
//
//	Дерево заполнено

//Введите ключ : 1
//Дерево :
//	m = 1    1
//
//	Введите ключ : 2
//	Дерево :
//	m = 2    1   2
//
//	Введите ключ : 3
//	Дерево :
//	m = 3    1   2   3
//
//	Введите ключ : 9
//	Дерево :
//	m = 4    1   2   3   9
//
//	Введите ключ : 8
//	Дерево :
//	m = 1    3
//	m = 2     1   2
//	m = 2     9   8
//
//	Введите ключ : 7
//	Дерево :
//	m = 1    3
//	m = 2     1   2
//	m = 3     7   9   8
//
//	Введите ключ : 5
//	Дерево :
//	m = 1    3
//	m = 2     1   2
//	m = 4     7   5   9   8
//
//	Введите ключ : 6
//	Дерево :
//	m = 2    3   6
//	m = 2     1   2
//	m = 2     7   5
//	m = 2     9   8
//
//	Введите ключ : 7
//	Дерево :
//	m = 2    3   6
//	m = 2     1   2
//	m = 2     7   5
//	m = 3     7   9   8
//
//	Введите ключ : 14
//	Дерево :
//	m = 2    3   6
//	m = 2     1   2
//	m = 2     7   5
//	m = 4     7   9   8  14
//
//	Введите ключ : 16
//	Дерево :
//	m = 3    3   6   8
//	m = 2     1   2
//	m = 2     7   5
//	m = 2     7   9
//	m = 2    14  16
//
//	Введите ключ : 17
//	Дерево :
//	m = 3    3   6   8
//	m = 2     1   2
//	m = 2     7   5
//	m = 2     7   9
//	m = 3    14  16  17
//
//	Введите ключ : 18
//	Дерево :
//	m = 3    3   6   8
//	m = 2     1   2
//	m = 2     7   5
//	m = 2     7   9
//	m = 4    14  16  17  18
//
//	Введите ключ : 19
//	Дерево :
//	m = 4    3   6   8  17
//	m = 2     1   2
//	m = 2     7   5
//	m = 2     7   9
//	m = 2    14  16
//	m = 2    18  19
//
//	Введите ключ : 20
//	Дерево :
//	m = 4    3   6   8  17
//	m = 2     1   2
//	m = 2     7   5
//	m = 2     7   9
//	m = 2    14  16
//	m = 3    18  19  20
//
//	Введите ключ : 21
//	Дерево :
//	m = 4    3   6   8  17
//	m = 2     1   2
//	m = 2     7   5
//	m = 2     7   9
//	m = 2    14  16
//	m = 4    18  19  20  21
//
//	Введите ключ : 22
//	Дерево :
//	m = 1    8
//	m = 2     3   6
//	m = 2      1   2
//	m = 2      7   5
//	m = 2      7   9
//	m = 2    17  20
//	m = 2     14  16
//	m = 2     18  19
//	m = 2     21  22
//
//	Введите ключ : 11
//	Дерево :
//	m = 1    8
//	m = 2     3   6
//	m = 2      1   2
//	m = 2      7   5
//	m = 2      7   9
//	m = 2    17  20
//	m = 3     11  14  16
//	m = 2     18  19
//	m = 2     21  22
//
//	Введите ключ : 13
//	Дерево :
//	m = 1    8
//	m = 2     3   6
//	m = 2      1   2
//	m = 2      7   5
//	m = 2      7   9
//	m = 2    17  20
//	m = 4     11  13  14  16
//	m = 2     18  19
//	m = 2     21  22
//
//	Введите ключ : 14
//	Дерево :
//	m = 1    8
//	m = 2     3   6
//	m = 2      1   2
//	m = 2      7   5
//	m = 2      7   9
//	m = 2    17  20
//	m = 4     11  13  14  16
//	m = 2     18  19
//	m = 2     21  22
//
//	Введите ключ : 15
//	Дерево :
//	m = 1    8
//	m = 2     3   6
//	m = 2      1   2
//	m = 2      7   5
//	m = 2      7   9
//	m = 3    14  17  20
//	m = 2     11  13
//	m = 2     16  15
//	m = 2     18  19
//	m = 2     21  22
//
//	Введите ключ : 16
//	Дерево :
//	m = 1    8
//	m = 2     3   6
//	m = 2      1   2
//	m = 2      7   5
//	m = 2      7   9
//	m = 3    14  17  20
//	m = 2     11  13
//	m = 2     16  15
//	m = 2     18  19
//	m = 2     21  22
//
//	Введите ключ : 17
//	Дерево :
//	m = 1    8
//	m = 2     3   6
//	m = 2      1   2
//	m = 2      7   5
//	m = 2      7   9
//	m = 3    14  17  20
//	m = 2     11  13
//	m = 2     16  15
//	m = 2     18  19
//	m = 2     21  22
//
//	Введите ключ : 18
//	Дерево :
//	m = 1    8
//	m = 2     3   6
//	m = 2      1   2
//	m = 2      7   5
//	m = 2      7   9
//	m = 3    14  17  20
//	m = 2     11  13
//	m = 2     16  15
//	m = 2     18  19
//	m = 3     18  21  22
//
//	Введите ключ : 0
//
//	Дерево заполнено
